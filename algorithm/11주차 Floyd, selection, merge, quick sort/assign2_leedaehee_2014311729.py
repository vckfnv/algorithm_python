# -*- coding: utf-8 -*-
"""assign2_sorting_student.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1A9XcVCmo3t3O9ZqkgFPF8XSTmDM4eOT0
"""

def selection_sort(arr):
    n = len(arr)

    for i in range(n-1):
        least = i
        # write your code :)
        find = i
        mini = i
        while find < n:
            if arr[find] < arr[mini]:
                mini = find
            else:
                find += 1
        arr[least], arr[mini] = arr[mini], arr[least]        
        
    return arr

def partition(arr, left, right):
    pivot = arr[left] # make the first element as pivot 
    pivotindex = left
    # write your code :)
    
    l = left
    h = right
    while l < h:
        while l <= h and arr[l] <= pivot:
            l = l+1
        while l <= h and arr[h] >= pivot:
            h = h-1
            
        if l <= h:
            arr[l], arr[h] = arr[h], arr[l]
            l += 1
            h -= 1
    
    arr[pivotindex], arr[h] = arr[h], arr[pivotindex]
    
    return h
# write your code :)
def quick_sort(arr, left, right):
    if left < right:
        p = partition(arr, left, right)
        quick_sort(arr, left, p-1) # sorts the left side of pivot 
        quick_sort(arr, p + 1, right) # sort the right side of pivot.

    return arr

def merge_sort(arr):
    n = len(arr)

    if n > 1:
        # find the mid point
        mid = n // 2
        left = arr[:mid]
        right = arr[mid:]

        # sort the left and right part
        merge_sort(left)
        merge_sort(right)

        # merge
        # write your code :)
        l = h = k = 0
        while l < len(left) and h < len(right):
            if left[l] < right[h]:
                arr[k] = left[l]
                l += 1
                k += 1
            else:
                arr[k] = right[h]
                h += 1
                k += 1
        while l < len(left):
            arr[k] = left[l]
            l += 1
            k += 1
        while h < len(right):
            arr[k] = right[h]
            h += 1
            k += 1
        
    return arr

# 2-1.  Implement (a) selection sorting (b) quick sorting and (c) merge sorting
def main():
    arr = [5, 3, 8, 4, 9 , 1, 6, 2, 7]
    print("selection sort", selection_sort(arr))
    arr = [5, 3, 8, 4, 9 , 1, 6, 2, 7]
    print("quick sort", quick_sort(arr, left = 0 , right = len(arr) - 1))
    arr = [38, 27, 43, 3, 9, 82, 10]
    print("merge sort", merge_sort(arr))
    
main()

# 2-2 Compare the three sorting algorithm running time
from random import randint, seed, sample
import timeit
def get_arr(count): 
    # this function wil be return ramdomly generated array
    seed(1113) # if you set up random seed, then you can get the same sequence of numbers
    arr = [randint(0, 9999) for _ in range(count)]
    return sample(arr, count)

count = 500 # write the size of array
# Commented out IPython magic to ensure Python compatibility.
arr = get_arr(count)
#% timeit -n 1 selection_sort(arr)
sele= timeit.timeit('selection_sort(arr)','from __main__ import selection_sort,arr', number = 1)
print(sele)
# Commented out IPython magic to ensure Python compatibility.
#arr = get_arr(count)
#% timeit -n 1 quick_sort(arr, left = 0 , right = len(arr)-1)
arr = get_arr(count)
qui= timeit.timeit('quick_sort(arr,left = 0, right = len(arr)-1)','from __main__ import quick_sort,arr', number = 1)
print(qui)
# Commented out IPython magic to ensure Python compatibility.
#arr = get_arr(count)
#% timeit -n 1 merge_sort(arr)
arr = get_arr(count)
mer= timeit.timeit('merge_sort(arr)','from __main__ import merge_sort,arr', number = 1)
print(mer)
# write the result :) 
rlist = sorted([sele, qui, mer])
for i in range(3):
    if rlist[i] == sele: rlist[i] = 'selection sort'
    if rlist[i] == qui: rlist[i] = 'quick sort'
    if rlist[i] == mer: rlist[i] = 'merge sort'
print('running time :\t %s > %s > %s' %(rlist[2],rlist[1],rlist[0]))

# running time XXXX sort > XXXX sort > XXXX sort
