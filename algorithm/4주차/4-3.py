# -*- coding: utf-8 -*-
"""week4_lab1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZdK8BlI9AhBHC8zQBNqMDcW54GQY10WR
"""

class Node:
    
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None

class BinarySearchTree:
    
    def __init__(self):
        self.root = None
    
    def insert(self, current_node, key):
        ## Insert a new node with given key to bst 
        """
        Input:  current_node, key
        Output: None
        """   
        if self.root == None:
            self.root = Node(key)
            
        elif not self.search(self.root, key):
            if current_node.key > key:
        
                if current_node.left != None:
                    self.insert(current_node.left, key)
                else:
                    current_node.left = Node(key)                

            elif current_node.key < key:
               
                if current_node.right != None:
                    self.insert(current_node.right,key)
                else:
                    current_node.right = Node(key)
                
    
    def search(self, current_node, key):
        ## Search a given key in bst 
        """
        Input:  current_node, key
        Output: return False if key is not in bst
                return the node if key is in bst
        """
        if self.root == None:
            return False
            
        elif current_node.key == key:
            return current_node
        
        elif current_node.key > key and current_node.left:
            
            self.search(current_node.left,key)
            
        elif current_node.key < key and current_node.right:
            
            self.search(current_node.right,key)



    def delete(self, current_node, key):
        
        prev, curr = None, self.root
        
        # 1. find the node
        while curr and curr.key != key:
            prev = curr
            curr = curr.left if key < curr.key else curr.right

        
        # 2. check if node exists
        if curr is None:
            return self.root
        
        # 3. check if there exists a successor to the node
        if curr.right is None:
            # 4. check if the node is the root
            if curr is self.root:
                curr = curr.left
            
            # node is internal to the tree
            if prev.left is curr:
                prev.left = curr.left
            else:
                prev.right = curr.left
                    
            curr.left = None
            return self.root

        # 5. find inorder successor
        prev_succ, succ = curr, curr.right
        while succ.left:
            prev_succ = succ
            succ = succ.left
        
        # 6. swap the values
        curr.key = succ.key
        
        # 7. handle the right child of the successor
        if prev_succ is curr:
            prev_succ.right = succ.right
        else:
            prev_succ.left = succ.right
            
        succ.right = None
        
        return self.root        


        
    def preorder(self, node):
        ## Completed Funtion - DO NOT REMOVE
        ## Display key(s) of the bst in preorder
        if node:
            print(node.key, end=" ")
            self.preorder(node.left)
            self.preorder(node.right)
            

def main():
    
    bst1 = BinarySearchTree()
    bst1.insert(bst1.root, 60)
    bst1.insert(bst1.root, 25)
    #bst1.insert(bst1.root, 100)
    bst1.insert(bst1.root, 35)
    bst1.insert(bst1.root, 17)
    #bst1.insert(bst1.root, 80)
    bst1.delete(bst1.root, 60)
    bst1.preorder(bst1.root)

    print()
    
    bst2 = BinarySearchTree()
    bst2.insert(bst2.root, "stupid")
    bst2.insert(bst2.root, "in")
    bst2.insert(bst2.root, "love")
    bst2.insert(bst2.root, "by")
    bst2.insert(bst2.root, "mad")
    bst2.insert(bst2.root, "clown")
    bst2.insert(bst2.root, "and")
    bst2.insert(bst2.root, "soyou")
    bst2.preorder(bst2.root)
    
main()
